<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Locations on Bing Maps</title>
	<script type="text/javascript" src="dd_XMLParser.js" async></script>
	<script type="text/javascript" src="dd_RESTService.js" async></script>
	<script type="text/javascript" src="ClientGlobalContext.js.aspx"></script>
	<script type="text/javascript" src="dd_chartMapConfig.js"></script>
	<script type="text/javascript">
		function loadMap() {  // We need to use a global callback because the Bing Map onscriptload parameter doesn't support namespaces... because <i>reasons</i>!
			chartMap.loadMap();
		}
		var chartMap = chartMap || {
			Settings: JSON.parse(configJSON),
			allPins: new Array(),
			init: function () {
				var bingMapScript = document.createElement('script');
				bingMapScript.setAttribute("type", "text/javascript");
				bingMapScript.setAttribute("src", chartMap.Settings.bingMapScriptUrl + "&onscriptload=loadMap");
				document.body.appendChild(bingMapScript);

				var parameters = chartMap.getParametersFromQuery(window.location.search.substring(1));
				var dataParam = chartMap.getParametersFromQuery(parameters["data"]);
				chartMap.entityTypeName = parameters["typename"];
				chartMap.chartId = dataParam["visid"];

				chartMap.loadChartConfig();
				chartMap.loadRecords();
			},
			loadMap: function () {
				if (!Microsoft.Maps.Search)
					Microsoft.Maps.loadModule('Microsoft.Maps.Search', { callback: chartMap.initBingMap });

				if (!Microsoft.Maps.Themes)
					Microsoft.Maps.loadModule('Microsoft.Maps.Themes.BingTheme', { callback: chartMap.initBingMap });

				if (!chartMap.PresentationDescription) {
					setTimeout(chartMap.loadMap, 10);
					return;
				}

				if (chartMap.PresentationDescription.MapType == 1) {
					Microsoft.Maps.registerModule("PointBasedClusteringModule", "dd_PointBasedClustering.min.js");
					Microsoft.Maps.loadModule("PointBasedClusteringModule", { callback: chartMap.initPointMap });
				}
				else if (chartMap.PresentationDescription.MapType == 2) {
					Microsoft.Maps.registerModule("HeatMapModule", "dd_HeatMapModule.js");
					Microsoft.Maps.loadModule("HeatMapModule", { callback: chartMap.initHeatMap });
				}
			},
			initBingMap: function () {
				if (Microsoft.Maps.Search && Microsoft.Maps.Themes && !chartMap.BingMap) {
					chartMap.BingMap = new Microsoft.Maps.Map(document.getElementById("mapDiv"), {
						credentials: chartMap.Settings.BingKey,
						enableClickableLogo: false,
						showDashboard: false,
						enableSearchLogo: false,
						theme: new Microsoft.Maps.Themes.BingTheme()
					});
					chartMap.searchManager = new Microsoft.Maps.Search.SearchManager(chartMap.BingMap);
					chartMap.BingMap.setView({ zoom: chartMap.Settings.Zoom, center: new Microsoft.Maps.Location(chartMap.Settings.CenterLat, chartMap.Settings.CenterLong) });
				}
			},
			initPointMap: function () {
				chartMap.clusterLayer = new PointBasedClusteredEntityCollection(
                    chartMap.BingMap,
                    {
                    	singlePinCallback: chartMap.createPin,
                    	clusteredPinCallback: chartMap.createClusteredPin,
                    	clusterRadius: chartMap.PresentationDescription.EnableClustering ? chartMap.PresentationDescription.ClusterRadius : -1,
                    	callback: chartMap.onDrawMapComplete
                    }
                );
			},
			initHeatMap: function () {
				chartMap.heatLayer = new HeatMapLayer(
                    chartMap.BingMap,
                    [],
                    {
                    	intensity: chartMap.PresentationDescription.Intensity,
                    	radius: chartMap.PresentationDescription.Radius,
                    	unit: chartMap.PresentationDescription.RadiusUnits,
                    	colourgradient: {
                    		"0.00": chartMap.PresentationDescription.Colour1,
                    		"0.25": chartMap.PresentationDescription.Colour2,
                    		"0.50": chartMap.PresentationDescription.Colour3,
                    		"0.75": chartMap.PresentationDescription.Colour4,
                    		"1.00": chartMap.PresentationDescription.Colour5
                    	},
                    	callback: chartMap.onDrawMapComplete
                    }
                );
			},
			onDrawMapComplete: function () {  // Executed every time the map finishes being redrawn, including user scrolling/zooming
			},
			loadChartConfig: function () {
				if (typeof dd_CRMService === "undefined" || typeof XMLParser === "undefined") {
					setTimeout(chartMap.loadChartConfig, 10, count);
					return;
				}

				dd_CRMService.Retrieve(
					chartMap.chartId, "SavedQueryVisualization",
					null, null,
					function (result) {
						chartMap.PresentationDescription = JSON.parse(result.PresentationDescription);
						chartMap.DataDescription = JSON.parse(result.DataDescription);

						chartMap.DataDescription.Latitude = (typeof chartMap.DataDescription.LatitudeField === 'string') ? chartMap.DataDescription.LatitudeField.toLowerCase() : "";
						chartMap.DataDescription.Longitude = (typeof chartMap.DataDescription.LongitudeField === 'string') ? chartMap.DataDescription.LongitudeField.toLowerCase() : "";
					},
					function (error) { chartMap.ShowErrorOnMap("There was a problem loading the map configuration"); }
				);
			},
			loadRecords: function () {
				chartMap.getEffectiveFetchXML();
			},
			getEffectiveFetchXML: function () {
				if (parent.effectiveFetchXml && Object.prototype.toString.call(parent.effectiveFetchXml) == "[object HTMLDivElement]") {
					chartMap.buildFetchXML(parent.effectiveFetchXml.getAttribute("value"));  // Web
				}
				else if (parent.$find("crmGrid")) {
					chartMap.buildFetchXML(parent.$find("crmGrid").GetParameter("effectiveFetchXml"));  // Outlook
				}
				else  // Retrieves the FetchXml using the provided viewId.  This is the only method that is technically supported, but it does not maintain user-filtered view results.  This was added to support "Chart-Only" subgrids on Forms and Dashboards, but it also makes a good fallback if the unsupported methods fail.
				{
					var parameters = chartMap.getParametersFromQuery(window.location.search.substring(1));
					var dataParam = chartMap.getParametersFromQuery(parameters["data"]);
					var viewId = dataParam["viewid"];
					chartMap.GetFetchXmlFromViewId(viewId);
				}
			},
			buildFetchXML: function (fetchXMLString) {
				if (!chartMap.DataDescription) {
					setTimeout(chartMap.buildFetchXML, 10, fetchXMLString);
					return;
				}

				if (!chartMap.PresentationDescription.ShowAllRecords) {  // if showallrecords is true, then it will already be defaulted to "count=5000" and "page=1"
					chartMap.DataDescription.fetchXML = chartMap.DataDescription.fetchXML.replace('count="250"', fetchXMLString.match(/count=".*?"/));
					chartMap.DataDescription.fetchXML = chartMap.DataDescription.fetchXML.replace('page="1"', fetchXMLString.match(/page=".*?"/));
				}

				chartMap.DataDescription.fetchXML = chartMap.DataDescription.fetchXML.replace("<order/>", fetchXMLString.match(/<order.*?\/>/));
				chartMap.DataDescription.fetchXML = chartMap.DataDescription.fetchXML.replace("<filter/>", fetchXMLString.match(/<filter.*<\/filter>/));

				chartMap.ExecuteFetchXmlRequest();
			},
			ExecuteFetchXmlRequest: function() {
				if (typeof dd_CRMService === "undefined" || typeof XMLParser === "undefined") {
					setTimeout(chartMap.ExecuteFetchXmlRequest, 10);
					return;
				}

				dd_CRMService.RetrieveFetchXml(chartMap.DataDescription.fetchXML, chartMap.getPinData, function (error) { chartMap.ShowErrorOnMap("There was a problem opening the record list"); });
			},
			GetFetchXmlFromViewId: function (viewId) {
				dd_CRMService.Retrieve(
					viewId, "SavedQuery", null, null,
					function (result) { chartMap.buildFetchXML(result.FetchXml); },
					function (error) { chartMap.ShowErrorOnMap("There was a problem reading the record list"); }
				);
			},
			getPinData: function (entityList) {
				var pinData = function (crmEntity) {
					this.Name = crmEntity.attributes[chartMap.DataDescription.NameField];
					this.Id = crmEntity.id;
					this.Address = crmEntity.compositeAddress;
					this.EntityType = chartMap.entityTypeName;
					this.latitude = crmEntity.attributes[chartMap.DataDescription.Latitude];
					this.longitude = crmEntity.attributes[chartMap.DataDescription.Longitude];
					this.weight = crmEntity.attributes[chartMap.DataDescription.NumericField];
				},
                entities = entityList.EntityCollection,
                mapConfig = chartMap.DataDescription;
				chartMap.geocodeCompleted = 0;
				chartMap.geocodeTotal = entities.length;

				for (var e in entities) {
					var entity = entities[e];
					entity.compositeAddress = [entity.attributes[mapConfig.AddressField], entity.attributes[mapConfig.CityField], entity.attributes[mapConfig.StateField], entity.attributes[mapConfig.CountryField], entity.attributes[mapConfig.PostCodeField]].filter(function (a) { return a != undefined }).join(", ");

					if (entity.attributes[mapConfig.Longitude] && entity.attributes[mapConfig.Latitude]) {  // We already have the coordinates
						chartMap.allPins.push(new pinData(entity));
						chartMap.geocodeComplete();
					}
					else if (entity.compositeAddress) {  // Must perform geocoding
						var userData = new pinData(entity);
						chartMap.sendGeocodeRequest(entity.compositeAddress, userData);
					}
					else {  // Skip any records with no address details
						chartMap.geocodeComplete();
					}
				}
			},
			sendGeocodeRequest: function (searchString, userData) {
				if (!chartMap.searchManager) {
					setTimeout(chartMap.sendGeocodeRequest, 10, searchString, userData);
					return;
				}

				chartMap.searchManager.geocode({
					where: searchString,
					count: 1,
					callback: chartMap.onGeocodeSuccess,
					errorCallback: chartMap.onGeocodeFail,
					userData: userData
				});
			},
			onGeocodeSuccess: function (result, userData) {
				if (result) {
					var topResult = result.results && result.results[0];
					if (topResult) {
						userData.latitude = topResult.location.latitude;
						userData.longitude = topResult.location.longitude;

						chartMap.allPins.push(userData);

						if (chartMap.PresentationDescription.EnableCaching) {
							chartMap.updateCoordinates(userData.Id, userData.EntityType, userData.longitude, userData.latitude)
						}
					}
				}
				chartMap.geocodeComplete();
			},
			onGeocodeFail: function (result, userData) {
				// TODO: add a logging or debug feature for admins, that would either store errors in the db, or show them in the UI
				chartMap.geocodeComplete();
			},
			geocodeComplete: function () {
				if (++chartMap.geocodeCompleted >= chartMap.geocodeTotal) {
					if (chartMap.PresentationDescription.MapType == 1) {
						chartMap.addPinsToMap();
					}
					else if (chartMap.PresentationDescription.MapType == 2) {
						chartMap.generateHeat();
					}

					chartMap.BingMap.setView({ bounds: Microsoft.Maps.LocationRect.fromLocations(chartMap.allPins) });
				}
			},
			addPinsToMap: function () {
				if (!chartMap.clusterLayer) {
					setTimeout(chartMap.addPinsToMap, 10);
					return;
				}
				chartMap.clusterLayer.SetData(chartMap.allPins);
			},
			generateHeat: function () {
				if (!chartMap.heatLayer) {
					setTimeout(chartMap.generateHeat, 10);
					return;
				}

				if (chartMap.PresentationDescription.HeatMapType && chartMap.PresentationDescription.HeatMapType == 2) {
					chartMap.allPins.Range = chartMap.PresentationDescription.IntensityRange;
				}
				else {
					chartMap.allPins.Range = 0;
				}

				chartMap.calculateRange();
				chartMap.heatLayer.SetPoints(chartMap.allPins);
			},
			createPin: function (data, clusterInfo) {
				var pin = {};
				pin.pin = new Microsoft.Maps.Pushpin(clusterInfo.center, { typeName: chartMap.PresentationDescription.PinSize });
				pin.infobox = new Microsoft.Maps.Infobox(
                    clusterInfo.center,
                    {
                    	title: data.Name,
                    	pushpin: pin.pin,
                    	description: data.Address,
                    	titleClickHandler: function () { Xrm.Utility.openEntityForm(data.EntityType, data.Id); }
                    });

				return pin;
			},
			createClusteredPin: function (clusterInfo) {
				var pin = { Description: "" };

				for (var i in clusterInfo.dataIndices) {
					pin.Description += '<a href="#" onclick="javascript:Xrm.Utility.openEntityForm(\'' + chartMap.entityTypeName + '\',\'' + chartMap.allPins[clusterInfo.dataIndices[i]].Id + '\');">' + chartMap.allPins[clusterInfo.dataIndices[i]].Name + "</a><br />";
				}
				pin.pin = new Microsoft.Maps.Pushpin(clusterInfo.center, { text: clusterInfo.dataIndices.length.toString() });
				pin.infobox = new Microsoft.Maps.Infobox(clusterInfo.center, { title: chartMap.PresentationDescription.ClusterTitle, pushpin: pin.pin, description: pin.Description });

				return pin;
			},
			updateCoordinates: function (id, type, longitude, latitude) {
				var record = {};
				record[chartMap.DataDescription.LatitudeField] = latitude;
				record[chartMap.DataDescription.LongitudeField] = longitude;

				dd_CRMService.Update(id, record, chartMap.DataDescription.EntitySchemaName, null, null);
			},
			calculateRange: function () {
				if (chartMap.allPins.Range == 1) {  // Calculated Range
					var weightArray = chartMap.allPins.map(function (x) { return x.weight; });

					if (chartMap.PresentationDescription.IntensityCalculation == 2) {  // Standard Deviation
						var STDev = chartMap.stdDev.getStandardDev(weightArray, 2);
						var Mean = chartMap.stdDev.getAverage(weightArray, 2);

						chartMap.allPins.Max = Mean + (STDev * chartMap.PresentationDescription.Deviations);
						chartMap.allPins.Min = Mean - (STDev * chartMap.PresentationDescription.Deviations);
					}
					else {  // Full Range
						chartMap.allPins.Max = Math.max.apply(null, weightArray);
						chartMap.allPins.Min = Math.min.apply(null, weightArray)
					}

					if (chartMap.allPins.Min < 0) {
						chartMap.allPins.Min = 0;
					}
				}
				else {  // Fixed range
					chartMap.allPins.Max = chartMap.PresentationDescription.MaxValue;
					chartMap.allPins.Min = chartMap.PresentationDescription.MinValue;
				}
			},
			ShowErrorOnMap: function (errorMessage) {
				errorMessage = errorMessage || "There was a problem loading this map.";
				if (chartMap.BingMap) {
					if (chartMap.BingMap.entities)
						chartMap.BingMap.entities.clear();

					var newElement = document.createElement("div");
					newElement.style.cssText = "position:absolute; width:100%; top:50%; text-Align:center";

					var innerElement = document.createElement("div");
					innerElement.innerHTML = "\u003ch2\u003eSorry :(\u003c/h2\u003e" + errorMessage + "\u003cbr/\u003ePlease contact your system administrator";

					innerElement.style.cssText = "background: #f8f7f5; padding:10px; color: #000;";
					newElement.appendChild(innerElement);
					chartMap.BingMap.getRootElement().appendChild(newElement);
				}
			},
			getParametersFromQuery: function (query) {
				var parametersDictionary = new Array();
				var parameters = query.split('&');
				for (var i in parameters) {
					var keyValuePair = parameters[i].split('=');
					parametersDictionary[unescape(keyValuePair[0])] = unescape(keyValuePair[1]);
				}
				return parametersDictionary;
			},
			stdDev: new function () {  // Helper for working with standard deviation
				var getNumWithSetDec = function (num, numOfDec) {
					var pow10s = Math.pow(10, numOfDec || 0);
					return (numOfDec) ? Math.round(pow10s * num) / pow10s : num;
				},
				getAverage = function (numArr, numOfDec) {
					var i = numArr.length, sum = 0;
					while (i--) {
						sum += numArr[i];
					}
					return getNumWithSetDec((sum / numArr.length), numOfDec);
				},
				getVariance = function (numArr, numOfDec) {
					var avg = getAverage(numArr, numOfDec), i = numArr.length, v = 0;
					while (i--) {
						v += Math.pow((numArr[i] - avg), 2);
					}
					v /= numArr.length;
					return getNumWithSetDec(v, numOfDec);
				},
				getStandardDev = function (numArr, numOfDec) {
					var stdDev = Math.sqrt(getVariance(numArr, numOfDec));
					return getNumWithSetDec(stdDev, numOfDec);
				};

				return {
					getStandardDev: getStandardDev,
					getAverage: getAverage
				}
			},
		}
	</script>
</head>
<body onload="chartMap.init()" style="overflow: hidden;">
	<div class="MicrosoftMap BingTheme MapTypeId_m medium" id="mapDiv"></div>
</body>
</html>