<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Locations on Bing Maps</title>
	<script type="text/javascript" src="dd_XMLParser.js"></script>
	<script type="text/javascript" src="dd_RESTService.js"></script>
	<script type="text/javascript" src="ClientGlobalContext.js.aspx"></script>
	<script type="text/javascript" id="BingMapScript"></script>
	<script type="text/javascript">
		var chartMap = (function(chartMap) {
			var allPins = [], config = {}, BingMap, PresentationDescription, DataDescription, geocodeCompleted = 0, geocodeTotal = 0;
			chartMap.init = function init() {
				retrieveBingMapAPIKey();
				loadChartConfig();
			};
			function loadChartConfig() {
				var parameters = Xrm.Page.context.getQueryStringParameters();
				var dataParam = parseQueryParameters(parameters.data);
				config.entityTypeName = parameters.typename;
				config.chartId = dataParam["visid"];
				config.viewId = dataParam["viewid"];

				dd_CRMService.Retrieve(
					config.chartId, "SavedQueryVisualization",
					null, null,
					function(result) {
						PresentationDescription = JSON.parse(result.PresentationDescription);
						DataDescription = JSON.parse(result.DataDescription);
						loadBingMapScript();
						loadData();
					},
					function(error) { ShowErrorOnMap("There was a problem loading the map configuration"); }
				);
			}
			function retrieveBingMapAPIKey() {
				dd_CRMService.RetrieveMultiple(
					"Organization", "$select=BingMapsApiKey&$top=1",
					function(results) {  //successCallback
						config.BingKey = results[0].BingMapsApiKey || "nokey";
					},
					function(error) { //errorCallback
						ShowErrorOnMap("Failed to Retrieve API Key");
					}
				);
			}
			function loadBingMapScript() {
				var bingMapScript = document.getElementById("BingMapScript");
				bingMapScript.onload = loadMap;
				bingMapScript.src = location.protocol + "//" + DataDescription.BingMapScriptUrl + (location.protocol === "https:" ? "&s=1" : "");
			}
			function loadMap() {
				if (typeof Microsoft === "undefined" || !Microsoft.Maps || !Microsoft.Maps.loadModule) {
					setTimeout(loadMap, 10);
					return;
				}

				Microsoft.Maps.loadModule('Microsoft.Maps.Themes.BingTheme', { callback: initBingMap });
			}
			function initBingMap() {
				if (!config.BingKey) {
					setTimeout(initBingMap, 10);
					return;
				}

				BingMap = new Microsoft.Maps.Map(document.getElementById("BingMap"), {
					credentials: config.BingKey,
					enableClickableLogo: false,
					showDashboard: false,
					enableSearchLogo: false,
					theme: new Microsoft.Maps.Themes.BingTheme()
				});
				BingMap.setView({ zoom: DataDescription.CenterZoom, center: new Microsoft.Maps.Location(DataDescription.CenterLat, DataDescription.CenterLong) });

				Microsoft.Maps.loadModule('Microsoft.Maps.Search', { callback: function () { config.searchManager = new Microsoft.Maps.Search.SearchManager(BingMap); } });
				if (PresentationDescription.MapType === 1) {
					Microsoft.Maps.registerModule("PointBasedClusteringModule", "dd_PointBasedClustering.js");
					Microsoft.Maps.loadModule("PointBasedClusteringModule", { callback: initPointMap });
				}
				else if (PresentationDescription.MapType === 2) {
					Microsoft.Maps.registerModule("HeatMapModule", "dd_HeatMapModule.js");
					Microsoft.Maps.loadModule("HeatMapModule", { callback: initHeatMap });
				}
			}
			function initPointMap() {
				config.clusterLayer = new PointBasedClusteredEntityCollection(
					BingMap,
					{
						singlePinCallback: createPin,
						clusteredPinCallback: createClusteredPin,
						clusterRadius: PresentationDescription.EnableClustering ? PresentationDescription.ClusterRadius : -1,
					}
				);
			}
			function initHeatMap() {
				config.heatLayer = new HeatMapLayer(
					BingMap, [],
					{
						intensity: PresentationDescription.Intensity,
						radius: PresentationDescription.Radius,
						unit: PresentationDescription.RadiusUnits,
						colourgradient: {
							"0.00": PresentationDescription.Colour1,
							"0.25": PresentationDescription.Colour2,
							"0.50": PresentationDescription.Colour3,
							"0.75": PresentationDescription.Colour4,
							"1.00": PresentationDescription.Colour5
						}
					}
				);

				if (PresentationDescription.DynamicRadius) {
					Microsoft.Maps.Events.addThrottledHandler(BingMap, 'viewchange', rescaleHeatMap, 250);
				}
			}
			function rescaleHeatMap(param) {
				var MaxZoomRadius = (PresentationDescription.RadiusUnits == "pixels") ? PresentationDescription.Radius : PresentationDescription.Radius / BingMap.getTargetMetersPerPixel()
				var radius = BingMap.getTargetZoom() / BingMap.getZoomRange().max * MaxZoomRadius;

				config.heatLayer.SetOptions({ radius: radius });
			}
			function loadData() {
				var FetchXml = "";
				if (parent.effectiveFetchXml && Object.prototype.toString.call(parent.effectiveFetchXml) == "[object HTMLDivElement]") {  // Web
					FetchXml = buildFetchXML(parent.effectiveFetchXml.getAttribute("value"));
				}
				else if (parent.$find("crmGrid")) {  // Outlook
					FetchXml = buildFetchXML(parent.$find("crmGrid").GetParameter("effectiveFetchXml"));
				}
				else  // Retrieves the FetchXml using the provided viewId.  This is the only method that is technically supported, but it does not maintain user-filtered results.  This was added to support "Chart-Only" subgrids on Forms and Dashboards, but it also makes a good fallback if the unsupported methods fail.
				{
					FetchXml = GetFetchXmlFromViewId(config.viewId);
				}

				dd_CRMService.RetrieveFetchXml(FetchXml, getPinData, function(error) { ShowErrorOnMap("There was a problem opening the record list"); });
			}
			function buildFetchXML(fetchXMLString) {
				var result = DataDescription.fetchXML;

				// TODO: use XPATH for this (dd_xmlparser.js)
				// 1. remove all attribute nodes
				// 2. add our address attributes
				// everything else stays the same, except maybe page/count

				if (!PresentationDescription.ShowAllRecords) {  // If showallrecords is true, then it will already be defaulted to "count=5000" and "page=1"
					result = result.replace('count="250"', fetchXMLString.match(/count=".*?"/));
					result = result.replace('page="1"', fetchXMLString.match(/page=".*?"/));
				}

				result = result.replace("<order/>", fetchXMLString.match(/<order.*?\/>/));
				result = result.replace("<filter/>", fetchXMLString.match(/<filter.*<\/filter>/));  // TODO: add support for link-entity filters

				return result;
			}
			function GetFetchXmlFromViewId(viewId) {
				var result = dd_CRMService.Retrieve(viewId, "SavedQuery", null, null);
				if (result.FetchXml)
					return result.FetchXml;
				else
					ShowErrorOnMap("There was a problem reading the record list");
			}
			function getPinData(entityList) {
				var pinData = function pinData(crmEntity) {  // Class to store pinData as it gets passed around
					this.Name = crmEntity[DataDescription.NameField];
					this.Id = crmEntity.id;
					this.Address = crmEntity.compositeAddress;
					this.EntityType = crmEntity.entityTypeName;
					this.latitude = crmEntity[DataDescription.LatitudeField];
					this.longitude = crmEntity[DataDescription.LongitudeField];
					this.weightValue = crmEntity[DataDescription.NumericField] || 0;
					this.retryCount = 0;
				};

				geocodeTotal = entityList.length;
				for (var e in entityList) {
					var entity = entityList[e];
					entity.compositeAddress = [entity[DataDescription.AddressField], entity[DataDescription.CityField], entity[DataDescription.StateField], entity[DataDescription.CountryField], entity[DataDescription.PostCodeField]].filter(function (a) { return a != undefined; }).join(", ");

					if (entity[DataDescription.LongitudeField] && entity[DataDescription.LatitudeField]) {  // We already have the coordinates
						allPins.push(new pinData(entity));
						geocodeComplete();
					}
					else if (entity.compositeAddress) {  // Must Perform Geocoding
						sendGeocodeRequest(entity.compositeAddress, new pinData(entity));
					}
					else {  // Skip records with no address details
						geocodeComplete();
					}
				}
			}
			function sendGeocodeRequest(searchString, pinData) {
				if (!config.searchManager) {
					setTimeout(sendGeocodeRequest, 10, searchString, pinData);
					return;
				}

				config.searchManager.geocode({
					where: searchString,
					count: 1,
					callback: onGeocodeSuccess,
					errorCallback: onGeocodeFail,
					userData: pinData
				});
			}
			function onGeocodeSuccess(result, pinData) {
				var CRMRecord = function CRMRecord(latitude, longitude) {  // Class for records to be updated
					this[DataDescription.LatitudeSchemaName] = latitude;
					this[DataDescription.LongitudeSchemaName] = longitude;
				}
				var topResult = result.results && result.results[0];
				if (topResult) {
					pinData.latitude = topResult.location.latitude;
					pinData.longitude = topResult.location.longitude;
					allPins.push(pinData);

					if (PresentationDescription.EnableCaching) {  // Update the record with discovered coordinates
						dd_CRMService.Update(pinData.Id, new CRMRecord(pinData.latitude, pinData.longitude), DataDescription.EntitySchemaName, function() { }, function() { });
					}
				}
				geocodeComplete();
			}
			function onGeocodeFail(result) {
				if (result.userData.retryCount < 3) {
					setTimeout(sendGeocodeRequest, 100, result.where, result.userData);  // Short delay and retry the failed record.
					return;
				}

				geocodeComplete();
			}
			function geocodeComplete() {
				if (++geocodeCompleted >= geocodeTotal) {
					if (PresentationDescription.MapType == 1) {
						addPinsToMap();
					}
					else if (PresentationDescription.MapType == 2) {
						generateHeat();
					}
					BingMap.setView({ bounds: Microsoft.Maps.LocationRect.fromLocations(allPins) });
				}
			}
			function addPinsToMap() {
				if (!config.clusterLayer) {
					setTimeout(addPinsToMap, 10);
					return;
				}
				config.clusterLayer.SetData(allPins);
			}
			function createPin(data, pinInfo) {
				var pin = {};
				pin.pin = new Microsoft.Maps.Pushpin(pinInfo.center);
				pin.infobox = new Microsoft.Maps.Infobox(
					pinInfo.center,
					{
						title: data.Name,
						pushpin: pin.pin,
						description: data.Address,
						titleClickHandler: function() { Xrm.Utility.openEntityForm(data.EntityType, data.Id); }
					});

				return pin;
			}
			function createClusteredPin(clusterInfo) {
				var pin = { Description: "" };

				for (var i in clusterInfo.dataIndices) {
					pin.Description += '<a href="#" onclick="javascript:Xrm.Utility.openEntityForm(\'' + config.entityTypeName + '\',\'' + allPins[clusterInfo.dataIndices[i]].Id + '\');">' + allPins[clusterInfo.dataIndices[i]].Name + "</a><br />";
				}
				pin.pin = new Microsoft.Maps.Pushpin(clusterInfo.center, { text: clusterInfo.dataIndices.length.toString() });
				pin.infobox = new Microsoft.Maps.Infobox(clusterInfo.center, { title: PresentationDescription.ClusterTitle, pushpin: pin.pin, description: pin.Description });

				return pin;
			}
			function generateHeat() {
				if (!config.heatLayer) {
					setTimeout(generateHeat, 10);
					return;
				}

				calculateIntensity();
				config.heatLayer.SetPoints(allPins);
			}
			function calculateIntensity() {
				var Max, Min, NegativeOffset = 0;
				if (PresentationDescription.HeatMapType === 2 && PresentationDescription.IntensityRange === 1) {  // Calculated Range
					var weightArray = allPins.map(function(x) { return x.weightValue; });
					if (PresentationDescription.IntensityCalculation == 2) {  // Standard Deviation
						var STDev = stdDev.getStandardDev(weightArray, 2);
						var Mean = stdDev.getAverage(weightArray, 2);

						Max = Mean + (STDev * PresentationDescription.Deviations);
						Min = Mean - (STDev * PresentationDescription.Deviations);
					}
					else {  // Full Range
						Max = Math.max.apply(null, weightArray);
						Min = Math.min.apply(null, weightArray)
					}
					if (Min < 0) {  // We now support displaying negative values on the heatmap, sooo...  TODO: add a config option to actually display them or not
						NegativeOffset = Math.abs(Min);
						Max += NegativeOffset;
						Min = 0;
					}
				}
				else {  // Fixed range
					Max = PresentationDescription.MaxValue;
					Min = PresentationDescription.MinValue;
				}

				for (var i = 0; i < allPins.length; i++) {  // Set specific intensity values for use in Heat Map
					var pinIntensity = ((allPins[i].weightValue + NegativeOffset - Min) / (Max - Min)).toFixed(2);
					pinIntensity = (pinIntensity <= 0) ? 0.01 : pinIntensity;  // Safety net
					pinIntensity = (pinIntensity > 1) ? 1 : pinIntensity;  // Safety net
					allPins[i].intensity = pinIntensity;
				}
			}
			function ShowErrorOnMap(errorMessage) {
				errorMessage = errorMessage || "There was a problem loading this map.";
				if (BingMap) {
					if (BingMap.entities) {
						BingMap.entities.clear();
					}
					var containerDiv = document.createElement("div");
					containerDiv.style.cssText = "position:absolute; width:100%; top:50%; text-Align:center";

					var errorDiv = document.createElement("div");
					errorDiv.innerHTML = "\u003ch2\u003eSorry :(\u003c/h2\u003e" + errorMessage + "\u003cbr/\u003ePlease contact your system administrator";
					errorDiv.style.cssText = "background: #f8f7f5; padding:10px; color: #000;";
					containerDiv.appendChild(errorDiv);
					BingMap.getRootElement().appendChild(containerDiv);
				}
			}
			function parseQueryParameters(query) {
				var parametersDictionary = new Array();
				var parameters = query.split('&');
				for (var i in parameters) {
					var keyValuePair = parameters[i].split('=');
					parametersDictionary[unescape(keyValuePair[0])] = unescape(keyValuePair[1]);
				}
				return parametersDictionary;
			}
			var stdDev = (function(stdDev) {  // Helper for working with standard deviation
				stdDev.getStandardDev = function getStandardDev(numArr, numOfDec) {
					var stdDeviation = Math.sqrt(getVariance(numArr, numOfDec));
					return getNumWithSetDec(stdDeviation, numOfDec);
				};
				stdDev.getAverage = function getAverage(numArr, numOfDec) {
					var i = numArr.length, sum = 0;
					while (i--) {
						sum += numArr[i];
					}
					return getNumWithSetDec((sum / numArr.length), numOfDec);
				}
				function getNumWithSetDec(num, numOfDec) {
					var pow10s = Math.pow(10, numOfDec || 0);
					return (numOfDec) ? Math.round(pow10s * num) / pow10s : num;
				}
				function getVariance(numArr, numOfDec) {
					var avg = stdDev.getAverage(numArr, numOfDec), i = numArr.length, v = 0;
					while (i--) {
						v += Math.pow((numArr[i] - avg), 2);
					}
					v /= numArr.length;
					return getNumWithSetDec(v, numOfDec);
				}
				return stdDev;
			}(stdDev || {}))
			return chartMap;
		}(chartMap || {}));
	</script>
</head>
<body onload="chartMap.init()" style="overflow: hidden;">
	<div class="MicrosoftMap BingTheme MapTypeId_m medium" id="BingMap"></div>
</body>
</html>
